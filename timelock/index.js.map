{"version":3,"file":"index.js","mappings":"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","sources":["webpack://timelock/webpack/bootstrap","webpack://timelock/webpack/runtime/define property getters","webpack://timelock/webpack/runtime/hasOwnProperty shorthand","webpack://timelock/webpack/runtime/make namespace object","webpack://timelock/./src/util.ts","webpack://timelock/./src/encrypt-cpu.ts","webpack://timelock/./src/encrypt-webgl.ts","webpack://timelock/./src/wasm.ts","webpack://timelock/./src/encrypt.ts","webpack://timelock/./src/decrypt.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const enum SIZE {\n  HASH = 32,\n  SALT = 12,\n  SALT_WITH_ID = SALT + 4,\n  PIXEL = 16,\n  CTX = 128,\n}\n\nexport const enum NUM {\n  ITER_PER_LOOP = 1e7,\n\n  // colors per thread\n  IN_COLOR = 8,\n  OUT_COLOR = 4,\n}\n\nexport type EncryptParams = {\n  plain: Uint8Array\n  cost: number\n  seedLen: number\n  cpuThread: number\n  gpuThread: number\n}\n\nexport type EncryptNode = {\n  name: string\n  iter: number\n  seedNum: number\n  seedLen: number\n  seeds: Uint8Array\n  salt: Uint8Array\n}\n\nexport type DecryptParams = {\n  cost: number\n  cipher: Uint8Array\n  nodes: EncryptNode[]\n}\n\nexport async function aesEncrypt(plain: Uint8Array, key: Uint8Array, iv: Uint8Array) {\n  const k = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt'])\n  const buf = await crypto.subtle.encrypt({name: 'AES-GCM', iv}, k, plain)\n  return new Uint8Array(buf)\n}\n\nexport async function aesDecrypt(cipher: Uint8Array, key: Uint8Array, iv: Uint8Array) {\n  const k = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['decrypt'])\n  const buf = await crypto.subtle.decrypt({name: 'AES-GCM', iv}, k, cipher)\n  return new Uint8Array(buf)\n}\n\nexport function fillRandomBytes(buf: Uint8Array) {\n  for (let i = 0; i < buf.length; i += 65536) {\n    const slice = buf.subarray(i, i + 65536)\n    crypto.getRandomValues(slice)\n  }\n}\n\nexport function xorBuf(dst: Uint8Array, src: Uint8Array, len: number) {\n  for (let i = 0; i < len; i++) {\n    dst[i] ^= src[i]\n  }\n}\n\nexport function indexBuf(buf: Uint8Array, sliceLen: number, index: number) {\n  const offset = index * sliceLen\n  return buf.subarray(offset, offset + sliceLen)\n}\n\nexport function cloneBuf(buf: Uint8Array) {\n  return buf.slice(0)\n}\n\nexport function concatBuf(bufs: Uint8Array[], size: number) {\n  const ret = new Uint8Array(size)\n  let pos = 0\n  for (const v of bufs) {\n    ret.set(v, pos)\n    pos += v.length\n  }\n  return ret\n}\n\nexport function isUint(value: number) {\n  return value === Math.floor(value)\n}\n\nexport function isPositiveInt(value: number) {\n  return value > 0 && isUint(value)\n}\n\nexport function isPowerOf2(value: number) {\n  return (value & (value - 1)) === 0\n}\n\nexport async function readCache(url: string) {\n  const cache = await caches.open('timelock')\n  return await cache.match(url)\n}\n\nexport async function writeCache(url: string, data: BodyInit) {\n  const cache = await caches.open('timelock')\n  const res = new Response(data)\n  await cache.put(url, res)\n}\n","import {\n  SIZE,\n  NUM,\n  indexBuf,\n  cloneBuf,\n  concatBuf,\n} from './util'\n\n//\n// page to worker message\n//\nconst enum ReqMsgType {\n  START,\n  STOP,\n  PAUSE,\n  RESUME,\n  BENCHMARK,\n}\ntype ReqMsgStart = {\n  type: ReqMsgType.START\n  seed: Uint8Array\n  salt: Uint8Array\n  iter: number\n}\ntype ReqMsgStop = {\n  type: ReqMsgType.STOP\n}\ntype ReqMsgPause = {\n  type: ReqMsgType.PAUSE\n}\ntype ReqMsgResume = {\n  type: ReqMsgType.RESUME\n}\ntype ReqMsgBenchmark = {\n  type: ReqMsgType.BENCHMARK\n  iter: number\n}\ntype ReqMsg =\n  ReqMsgStart | ReqMsgStop | ReqMsgPause | ReqMsgResume | ReqMsgBenchmark\n\n//\n// worker to page message\n//\nconst enum ResMsgType {\n  PROGRESS,\n  COMPLETE,\n  STOPPED,\n  BENCHMARK,\n}\ntype ResMsgProgress = {\n  type: ResMsgType.PROGRESS\n  iterAdded: number\n}\ntype ResMsgComplete = {\n  type: ResMsgType.COMPLETE\n  hash: Uint8Array\n}\ntype ResMsgStopped = {\n  type: ResMsgType.STOPPED\n}\ntype ResMsgBenchmark = {\n  type: ResMsgType.BENCHMARK\n  startTime: number\n  endTime: number\n}\ntype ResMsg =\n  ResMsgProgress | ResMsgComplete | ResMsgStopped | ResMsgBenchmark\n\n//\n// this function will be run in the worker context\n//\nconst workerEnv = () => {\n  const sendMsgToPage: ((msg: ResMsg) => void) = postMessage\n\n  let pausedSignal: Promise<void> | undefined\n  let resumeCallback: () => void\n  let isStopping: boolean\n\n\n  async function start(seed: Uint8Array, salt: Uint8Array, iter: number) {\n    isStopping = false\n\n    const pbkdfOpt: Pbkdf2Params = {\n      name: 'PBKDF2',\n      hash: 'SHA-256',\n      salt,\n      iterations: 0,\n    }\n    const loop = Math.ceil(iter / NUM.ITER_PER_LOOP)\n\n    let hash = seed\n    let iterRemain = iter\n\n    for (let i = 0; i < loop; i++) {\n      pbkdfOpt.iterations = Math.min(iterRemain, NUM.ITER_PER_LOOP)\n      iterRemain -= NUM.ITER_PER_LOOP\n\n      const k = await crypto.subtle.importKey(\n        'raw', hash, 'PBKDF2', false, ['deriveBits']\n      )\n      const buf = await crypto.subtle.deriveBits(pbkdfOpt, k, SIZE.HASH * 8)\n      hash = new Uint8Array(buf)\n\n      if (pausedSignal) {\n        await pausedSignal\n      }\n      if (isStopping) {\n        sendMsgToPage({\n          type: ResMsgType.STOPPED,\n        })\n        return\n      }\n      sendMsgToPage({\n        type: ResMsgType.PROGRESS,\n        iterAdded: pbkdfOpt.iterations,\n      })\n    }\n    sendMsgToPage({\n      type: ResMsgType.COMPLETE,\n      hash,\n    })\n  }\n\n  async function benchmark(iter: number) {\n    const pwd = crypto.getRandomValues(new Uint8Array(32))\n    const opt: Pbkdf2Params = {\n      name: 'PBKDF2',\n      hash: 'SHA-256',\n      salt: new Uint8Array(16),\n      iterations: iter,\n    }\n    const key = await crypto.subtle.importKey(\n      'raw', pwd, 'PBKDF2', false, ['deriveBits']\n    )\n    const startTime = performance.now()\n    await crypto.subtle.deriveBits(opt, key, SIZE.HASH * 8)\n    const endTime = performance.now()\n\n    sendMsgToPage({\n      type: ResMsgType.BENCHMARK,\n      startTime,\n      endTime,\n    })\n  }\n\n\n  self.onmessage = (e) => {\n    const msg: ReqMsg = e.data\n\n    switch (msg.type) {\n    case ReqMsgType.START:\n      start(msg.seed, msg.salt, msg.iter)\n      break\n    case ReqMsgType.STOP:\n      isStopping = true\n      break\n    case ReqMsgType.PAUSE:\n      pausedSignal = new Promise(resolve => {\n        resumeCallback = resolve\n      })\n      break\n    case ReqMsgType.RESUME:\n      resumeCallback()\n      pausedSignal = undefined\n      break\n    case ReqMsgType.BENCHMARK:\n      benchmark(msg.iter)\n      break\n    }\n  }\n}\n\nclass MyWorker extends Worker {\n  constructor(url: string, public threadId: number) {\n    super(url)\n  }\n  sendMsg(msg: ReqMsg) {\n    super.postMessage(msg)\n  }\n}\n\nconst workerPool: MyWorker[] = []\nlet workerUrl: string\n\n\nfunction allocWorker(id: number) {\n  if (!workerUrl) {\n    const code = '(' + workerEnv + ')()'\n    const blob = new Blob([code])\n    workerUrl = URL.createObjectURL(blob)\n  }\n  let worker = workerPool[id]\n  if (!worker) {\n    worker = new MyWorker(workerUrl, id)\n    worker.onmessage = onWorkerMsg\n    workerPool[id] = worker\n  }\n  return worker\n}\n\n\nlet completedHashes: Uint8Array[]\nlet completedNum: number\nlet threadNum: number\n\nlet benchmarkInfo: ResMsgBenchmark[]\nlet benchmarkCallback: (time: number) => void\n\n\nfunction sendMsgToWorkers(msg: ReqMsg) {\n  for (let i = 0; i < threadNum; i++) {\n    workerPool[i].sendMsg(msg)\n  }\n}\n\nfunction onWorkerMsg(this: Worker, e: MessageEvent) {\n  const {threadId} = this as MyWorker\n  const msg: ResMsg = e.data\n\n  switch (msg.type) {\n  case ResMsgType.PROGRESS:\n    encryptOnProgress(msg.iterAdded)\n    break\n  case ResMsgType.COMPLETE:\n    completedHashes[threadId] = msg.hash\n    if (++completedNum === threadNum) {\n      const buf = concatBuf(completedHashes, threadNum * SIZE.HASH)\n      encryptOnComplete(buf)\n    }\n    break\n  case ResMsgType.STOPPED:\n    encryptOnComplete()\n    break\n  case ResMsgType.BENCHMARK:\n    if (benchmarkInfo.push(msg) === threadNum) {\n      const startTimeMin = Math.min(...benchmarkInfo.map(v => v.startTime))\n      const endTimeMax = Math.max(...benchmarkInfo.map(v => v.endTime))\n      const totalTime = endTimeMax - startTimeMin\n      benchmarkCallback(totalTime)\n    }\n    break\n  }\n}\n\nfunction benchmarkThread(thread: number, iter: number) {\n  threadNum = thread\n  benchmarkInfo = []\n\n  for (let p = 0; p < thread; p++) {\n    const worker = allocWorker(p)\n    worker.sendMsg({\n      type: ReqMsgType.BENCHMARK,\n      iter,\n    })\n  }\n  return new Promise<number>(resolve => {\n    benchmarkCallback = resolve\n  })\n}\n\n\nexport async function benchmark(\n  onProgress: (iterPerMs: number, thread: number) => void\n) {\n  const MAX_LOSS_RATIO = 1.2\n  const PROBE_ITER = 2e6\n  const THREAD_GROW = 1.2\n\n  console.log('evaluating CPU single thread performance...')\n\n  const probeTime = await benchmarkThread(1, PROBE_ITER)\n  const iterPerSec = PROBE_ITER / probeTime * 1000 | 0\n\n  const singleThreadTime = await benchmarkThread(1, iterPerSec)\n  const iterPerMs = iterPerSec / singleThreadTime | 0\n\n  console.log('speed: ~' + iterPerMs + ' iter/ms')\n\n  console.log('estimating CPU thread count...')\n  let thread = 1\n\n  if ('safari' in window) {\n    thread = navigator.hardwareConcurrency\n  }\n\n  for (;;) {\n    const tryThread = Math.ceil(thread * THREAD_GROW)\n    // init worker\n    await benchmarkThread(tryThread, 1)\n\n    const totalTime = await benchmarkThread(tryThread, iterPerSec)\n    const ratio = totalTime / singleThreadTime\n\n    onProgress(iterPerMs, tryThread)\n    console.log('try thread:', tryThread, 'ratio:', ratio)\n\n    if (ratio > MAX_LOSS_RATIO) {\n      break\n    }\n    thread = tryThread\n  }\n  onProgress(iterPerMs, thread)\n}\n\n\nlet encryptOnComplete: (hashes?: Uint8Array) => void\nlet encryptOnProgress: (iterAdded: number) => void\n\nexport function start(\n  thread: number,\n  seedsBuf: Uint8Array,\n  seedLen: number,\n  saltBuf: Uint8Array,\n  iter: number,\n  onProgress: typeof encryptOnProgress,\n) {\n  threadNum = thread\n  completedHashes = []\n  completedNum = 0\n  encryptOnProgress = onProgress\n\n  const saltIdBuf = new Uint8Array(SIZE.SALT_WITH_ID)\n  const saltIdView = new DataView(saltIdBuf.buffer)\n  saltIdBuf.set(saltBuf)\n\n  for (let p = 0; p < thread; p++) {\n    const seed = indexBuf(seedsBuf, seedLen, p)\n    saltIdView.setUint32(SIZE.SALT, p)\n\n    const worker = allocWorker(p)\n    worker.sendMsg({\n      type: ReqMsgType.START,\n      seed: cloneBuf(seed),\n      salt: saltIdBuf,\n      iter,\n    })\n  }\n  return new Promise<Uint8Array | undefined>(resolve => {\n    encryptOnComplete = resolve\n  })\n}\n\nexport function stop() {\n  sendMsgToWorkers({\n    type: ReqMsgType.STOP,\n  })\n}\n\nexport function pause() {\n  sendMsgToWorkers({\n    type: ReqMsgType.PAUSE,\n  })\n}\n\nexport function resume() {\n  sendMsgToWorkers({\n    type: ReqMsgType.RESUME,\n  })\n}\n","import {WebGL2Const as GL} from './webgl-const'\nimport {SIZE, NUM} from './util'\nimport FRAG_SHADER from './assets/shader.glsl'\n\n//\n// page to worker message\n//\nconst enum ReqMsgType {\n  INIT,\n  START,\n  STOP,\n  PAUSE,\n  RESUME,\n  SET_ITER_PER_DRAW,\n  SET_THREAD,\n  BENCHMARK,\n}\ntype ReqMsgInit = {\n  type: ReqMsgType.INIT\n  shader: string\n}\ntype ReqMsgStart = {\n  type: ReqMsgType.START\n  ctxBuf: Uint32Array\n  iter: number\n}\ntype ReqMsgStop = {\n  type: ReqMsgType.STOP\n}\ntype ReqMsgPause = {\n  type: ReqMsgType.PAUSE\n}\ntype ReqMsgResume = {\n  type: ReqMsgType.RESUME\n}\ntype ReqMsgSetIterPerDraw = {\n  type: ReqMsgType.SET_ITER_PER_DRAW\n  iter: number\n}\ntype ReqMsgSetThread = {\n  type: ReqMsgType.SET_THREAD\n  thread: number\n}\ntype ReqMsgBenchmark = {\n  type: ReqMsgType.BENCHMARK\n  iter: number\n  thread: number\n}\ntype ReqMsg =\n  ReqMsgInit | ReqMsgStart | ReqMsgStop | ReqMsgPause | ReqMsgResume |\n  ReqMsgSetIterPerDraw | ReqMsgSetThread | ReqMsgBenchmark\n\n//\n// worker to page message\n//\nconst enum ResMsgType {\n  BENCHMARK,\n  PROGRESS,\n  COMPLETE,\n  INIT,\n}\ntype ResMsgProgress = {\n  type: ResMsgType.PROGRESS\n  iterAdded: number\n}\ntype ResMsgComplete = {\n  type: ResMsgType.COMPLETE\n  ctxBuf?: Uint32Array\n}\ntype ResMsgBenchmark = {\n  type: ResMsgType.BENCHMARK\n  time: number\n}\ntype ResMsgInit = {\n  type: ResMsgType.INIT\n  errMsg: string\n}\ntype ResMsg =\n  ResMsgInit | ResMsgProgress | ResMsgComplete | ResMsgBenchmark\n\n//\n// this function will be run in the worker context\n//\nconst workerEnv = () => {\n  const sendMsgToPage: ((msg: ResMsg) => void) = postMessage\n\n  // \"Transform Feedback\" is simpler, but crashes frequently,\n  // so we still use the GPGPU solution of WebGL1.\n\n  //\n  // threadNum = texW * texH\n  //\n  // inTex:\n  //\n  // |----------- texW ------------|\n  // |             Ra             texH\n  // |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n  // |             Rb             texH\n  // |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n  // |            ....             |\n  // |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n  // |             Ob             texH\n  // |-----------------------------|\n  // (Ra, Rb, Wa, Wb, Ia, Ib, Oa, Ob)\n  //\n  //\n  // outTex:\n  //\n  // color_attachment0\n  // |----------- texW ------------|\n  // |             Ra             texH\n  // |-----------------------------|\n  //\n  // color_attachment1\n  // |----------- texW ------------|\n  // |             Rb             texH\n  // |-----------------------------|\n  //\n  // color_attachment2\n  // |----------- texW ------------|\n  // |             Wa             texH\n  // |-----------------------------|\n  //\n  // color_attachment3\n  // |----------- texW ------------|\n  // |             Wb             texH\n  // |-----------------------------|\n  //\n  const texH = 4\n  let texW: number\n\n  let gl: WebGL2RenderingContext\n  let iterHandle: WebGLUniformLocation\n  let iterPerDraw: number\n  let threadNum: number\n\n  let isStopping: boolean\n  let pausedSignal: Promise<void> | undefined\n  let resumeCallback: () => void\n\n\n  function sleep(ms: number) {\n    return new Promise(fn => {\n      setTimeout(fn, ms)\n    })\n  }\n\n  function createShader(code: string, type: number) {\n    const shader = gl.createShader(type)\n    if (!shader) {\n      throw Error('createShader failed')\n    }\n    gl.shaderSource(shader, code)\n    gl.compileShader(shader)\n\n    if (!gl.getShaderParameter(shader, GL.COMPILE_STATUS)) {\n      const msg = gl.getShaderInfoLog(shader)!\n      throw Error(msg)\n    }\n    return shader\n  }\n\n  function initWebGl(shader: string) {\n    const canvas = new OffscreenCanvas(0, 0)\n\n    const ctx = canvas.getContext('webgl2', {\n      failIfMajorPerformanceCaveat: true,\n      powerPreference: 'high-performance',\n    })\n    if (!ctx) {\n      throw Error('webgl2 is not available')\n    }\n    gl = ctx\n\n    canvas.oncontextlost = () => {\n      console.warn('webgl oncontextlost')\n    }\n    canvas.oncontextrestored = () => {\n      console.warn('webgl oncontextrestored')\n    }\n\n    const vertexData = new Float32Array([\n      -1, +1, // left top\n      -1, -1, // left bottom\n      +1, +1, // right top\n      +1, -1, // right bottom\n    ])\n    gl.bindBuffer(GL.ARRAY_BUFFER, gl.createBuffer())\n    gl.bufferData(GL.ARRAY_BUFFER, vertexData, GL.STATIC_DRAW)\n\n    const program = gl.createProgram()\n    if (!program) {\n      throw Error('createProgram failed')\n    }\n    const VERTEX_SHADER = `\\\n#version 300 es\nin vec2 v_pos;\nvoid main() {\n  gl_Position = vec4(v_pos, 0., 1.);\n}`\n    const vertexShader = createShader(VERTEX_SHADER, GL.VERTEX_SHADER)\n\n    const fragShaderCode = shader.replace('__TEX_H__', texH + 'u')\n    const fragShader = createShader(fragShaderCode, GL.FRAGMENT_SHADER)\n\n    gl.attachShader(program, fragShader)\n    gl.attachShader(program, vertexShader)\n\n    gl.linkProgram(program)\n    gl.useProgram(program)\n\n    const posHandle = 0\n    gl.vertexAttribPointer(posHandle, 2 /*vec2*/, GL.FLOAT, false, 0, 0)\n    gl.enableVertexAttribArray(posHandle)\n\n    iterHandle = gl.getUniformLocation(program, 'in_iter')!\n\n    const frameBuffer = gl.createFramebuffer()\n    if (!frameBuffer) {\n      throw Error('createFramebuffer failed')\n    }\n    gl.bindFramebuffer(GL.FRAMEBUFFER, frameBuffer)\n  }\n\n  function setIterPerDraw(value: number) {\n    if (iterPerDraw === value) {\n      return\n    }\n    iterPerDraw = value\n\n    // 1x iter => 2x hash\n    gl.uniform1ui(iterHandle, value * 2)\n  }\n\n  function setThread(value: number) {\n    if (threadNum === value) {\n      return\n    }\n    threadNum = value\n\n    // threadNum is a power of 2\n    texW = threadNum / texH\n    gl.viewport(0, 0, texW, texH)\n\n    for (let i = 0; i < NUM.OUT_COLOR; i++) {\n      const outTex = gl.createTexture()\n      if (!outTex) {\n        throw Error('create outTex failed')\n      }\n      gl.bindTexture(GL.TEXTURE_2D, outTex)\n\n      gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA32UI, texW, texH,\n        0, GL.RGBA_INTEGER, GL.UNSIGNED_INT, null)\n\n      gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0 + i,\n        GL.TEXTURE_2D, outTex, 0)\n    }\n\n    gl.drawBuffers([\n      GL.COLOR_ATTACHMENT0, GL.COLOR_ATTACHMENT1,\n      GL.COLOR_ATTACHMENT2, GL.COLOR_ATTACHMENT3,\n    ])\n\n    const inTex = gl.createTexture()\n    if (!inTex) {\n      throw Error('create inTex failed')\n    }\n    gl.bindTexture(GL.TEXTURE_2D, inTex)\n    gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST)\n    gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST)\n  }\n\n  function write(buf: Uint32Array) {\n    gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA32UI, texW, texH * NUM.IN_COLOR,\n      0, GL.RGBA_INTEGER, GL.UNSIGNED_INT, buf)\n  }\n\n  function read(buf: Uint32Array) {\n    for (let i = 0; i < NUM.OUT_COLOR; i++) {\n      const ptr = i * threadNum * SIZE.PIXEL\n\n      gl.readBuffer(GL.COLOR_ATTACHMENT0 + i)\n      gl.readPixels(0, 0, texW, texH,\n        GL.RGBA_INTEGER, GL.UNSIGNED_INT, buf, ptr / 4)\n    }\n  }\n\n  function draw() {\n    gl.drawArrays(GL.TRIANGLE_STRIP, 0, 4)\n\n    // copy outTex[i] to inTex at P(0, i * texH)\n    for (let i = 0; i < NUM.OUT_COLOR; i++) {    \n      const dstX = 0\n      const dstY = i * texH\n\n      gl.readBuffer(GL.COLOR_ATTACHMENT0 + i)\n      gl.copyTexSubImage2D(GL.TEXTURE_2D, 0, dstX, dstY, 0, 0, texW, texH)\n    }\n  }\n\n  async function benchmark(thread: number, iter: number) {\n    setThread(thread)\n    setIterPerDraw(iter)\n\n    const ctxBuf = new Uint32Array(thread * NUM.IN_COLOR * SIZE.PIXEL / 4)\n    write(ctxBuf)\n\n    const SAMPLE_NUM = 30\n    let timeMin = 1e9\n\n    for (let i = 0; i < SAMPLE_NUM; i++) {\n      const startTime = performance.now()\n      draw()\n      read(ctxBuf)\n      const endTime = performance.now()\n\n      const time = endTime - startTime\n      if (time < timeMin) {\n        timeMin = time\n      }\n      if (time < 16) {\n        break\n      }\n      await sleep(1)\n    }\n\n    sendMsgToPage({\n      type: ResMsgType.BENCHMARK,\n      time: timeMin,\n    })\n  }\n\n\n  const DRAWS_PER_SYNC = 10\n\n  async function start(params: ReqMsgStart) {\n    isStopping = false\n\n    const {ctxBuf, iter} = params\n    write(ctxBuf)\n\n    let iterRemain = iter\n    let iterAdded = 0\n    let drawCount = 0\n\n    for (;;) {\n      if (iterRemain <= iterPerDraw) {\n        const backup = iterPerDraw\n        setIterPerDraw(iterRemain)\n        draw()\n        setIterPerDraw(backup)\n\n        iterAdded += iterRemain * threadNum\n        sendMsgToPage({\n          type: ResMsgType.PROGRESS,\n          iterAdded,\n        })\n        break\n      }\n      draw()\n      iterRemain -= iterPerDraw\n      iterAdded += iterPerDraw * threadNum\n\n      // TODO: WebGLSync\n      if (++drawCount === DRAWS_PER_SYNC) {\n        drawCount = 0\n        read(ctxBuf)\n\n        sendMsgToPage({\n          type: ResMsgType.PROGRESS,\n          iterAdded,\n        })\n        iterAdded = 0\n        await sleep(1)\n\n        if (pausedSignal) {\n          await pausedSignal\n        }\n        if (isStopping) {\n          return\n        }\n      }\n    }\n    read(ctxBuf)\n    sendMsgToPage({\n      type: ResMsgType.COMPLETE,\n      ctxBuf: gl.isContextLost() ? undefined : ctxBuf,\n    })\n  }\n\n  function init(shader: string) {\n    let errMsg = ''\n    try {\n      initWebGl(shader)\n    } catch (err: any) {\n      errMsg = err.message\n    }\n    sendMsgToPage({\n      type: ResMsgType.INIT,\n      errMsg,\n    })\n  }\n\n\n  self.onmessage = (e) => {\n    const msg: ReqMsg = e.data\n\n    switch (msg.type) {\n    case ReqMsgType.INIT:\n      init(msg.shader)\n      break\n    case ReqMsgType.START:\n      start(msg)\n      break\n    case ReqMsgType.STOP:\n      isStopping = true\n      break\n    case ReqMsgType.PAUSE:\n      pausedSignal = new Promise(resolve => {\n        resumeCallback = resolve\n      })\n      break\n    case ReqMsgType.RESUME:\n      resumeCallback()\n      pausedSignal = undefined\n      break\n    case ReqMsgType.SET_ITER_PER_DRAW:\n      setIterPerDraw(msg.iter)\n      break\n    case ReqMsgType.SET_THREAD:\n      setThread(msg.thread)\n      break\n    case ReqMsgType.BENCHMARK:\n      benchmark(msg.thread, msg.iter)\n      break\n    }\n  }\n}\n\n\nlet worker: Worker\n\nfunction sendMsgToWorker(msg: ReqMsg) {\n  worker.postMessage(msg)\n}\n\nfunction onWorkerMsg(e: MessageEvent) {\n  const msg: ResMsg = e.data\n\n  switch (msg.type) {\n  case ResMsgType.INIT:\n    initCallback(msg.errMsg)\n    break\n  case ResMsgType.PROGRESS:\n    progressCallback(msg.iterAdded)\n    break\n  case ResMsgType.COMPLETE:\n    completeCallback(msg.ctxBuf)\n    break\n  case ResMsgType.BENCHMARK:\n    benchmarkThreadCallback(msg.time)\n    break\n  }\n}\n\nlet initCallback: (err: string) => void\n\nexport function init() {\n  const code = '(' + workerEnv + ')()'\n  const blob = new Blob([code])\n  const workerUrl = URL.createObjectURL(blob)\n\n  worker = new Worker(workerUrl)\n  worker.onmessage = onWorkerMsg\n\n  sendMsgToWorker({\n    type: ReqMsgType.INIT,\n    shader: FRAG_SHADER,\n  })\n  return new Promise<string>(resolve => {\n    initCallback = resolve\n  })\n}\n\n\nlet benchmarkThreadCallback: (time: number) => void\n\nfunction benchmarkThread(thread: number, iter: number) {\n  sendMsgToWorker({\n    type: ReqMsgType.BENCHMARK,\n    iter,\n    thread,\n  })\n  return new Promise<number>(resolve => {\n    benchmarkThreadCallback = resolve\n  })\n}\n\nexport async function benchmark(\n  onProgress: (iterPerMs: number, thread: number) => void\n) {\n  let iter = 256\n  let thread = 256\n\n  let singleThreadTime: number\n  console.log('evaluating GPU single thread performance...')\n\n  for (;;) {\n    setIterPerDraw(iter)\n    singleThreadTime = await benchmarkThread(thread, iter)\n\n    onProgress(iter / singleThreadTime | 0, thread)\n    console.log('try iter:', iter, 'time:', singleThreadTime)\n\n    if (singleThreadTime > 17) {\n      break\n    }\n    iter = iter * 1.25 | 0\n  }\n\n  let multiThreadTime = singleThreadTime\n  console.log('estimating GPU thread count...')\n\n  for (;;) {\n    const tryThread = thread * 2\n    const time = await benchmarkThread(tryThread, iter)\n    if (time < 10) {\n      console.warn('webgl crashed')\n      multiThreadTime = -1\n      break\n    }\n    if (time < singleThreadTime) {\n      singleThreadTime = time\n    }\n    const ratio = time / singleThreadTime\n    onProgress(iter / time | 0, tryThread)\n\n    console.log('try thread:', tryThread, 'ratio:', ratio)\n    if (ratio >= 1.9) {\n      break\n    }\n    thread = tryThread\n    multiThreadTime = time\n  }\n\n  onProgress(iter / multiThreadTime | 0, thread)\n}\n\n\nlet completeCallback: (ctxBuf?: Uint32Array) => void\nlet progressCallback: (iterAdded: number) => void\n\nexport function start(\n  ctxBuf: Uint32Array,\n  iter: number,\n  onProgress: typeof progressCallback,\n) {\n  progressCallback = onProgress\n\n  sendMsgToWorker({\n    type: ReqMsgType.START,\n    ctxBuf: ctxBuf.slice(0),\n    iter,\n  })\n  return new Promise<Uint32Array | undefined>(resolve => {\n    completeCallback = resolve\n  })\n}\n\nexport function stop() {\n  sendMsgToWorker({\n    type: ReqMsgType.STOP,\n  })\n}\n\nexport function pause() {\n  sendMsgToWorker({\n    type: ReqMsgType.PAUSE,\n  })\n}\n\nexport function resume() {\n  sendMsgToWorker({\n    type: ReqMsgType.RESUME,\n  })\n}\n\nexport function setIterPerDraw(value: number) {\n  sendMsgToWorker({\n    type: ReqMsgType.SET_ITER_PER_DRAW,\n    iter: value,\n  })\n}\n\nexport function setThread(value: number) {\n  sendMsgToWorker({\n    type: ReqMsgType.SET_THREAD,\n    thread: value,\n  })\n}\n","import {SIZE} from './util'\nimport WASM_URI from './assets/timelock.wasm'\n\n\nlet wasmObj: {\n  memory: WebAssembly.Memory\n\n  get_hashes_buf: () => number\n  get_salt_buf: () => number\n  get_ctx_buf: () => number\n  pbkdf2_pre: (gpu_thread: number, elem_len: number) => void\n  pbkdf2_post: (gpu_thread: number) => void\n}\n\nexport async function init() {\n  const res = await fetch(WASM_URI)\n  const {instance} = await WebAssembly.instantiateStreaming(res)\n  wasmObj = instance.exports as any\n}\n\nexport function getSaltBuf() {\n  const ptr = wasmObj.get_salt_buf()\n  return new Uint8Array(wasmObj.memory.buffer, ptr, SIZE.SALT)\n}\n\nexport function getHashesBuf(thread: number) {\n  const ptr = wasmObj.get_hashes_buf()\n  return new Uint8Array(wasmObj.memory.buffer, ptr, thread * SIZE.HASH)\n}\n\nexport function getCtxBuf(gpuThread: number) {\n  const ptr = wasmObj.get_ctx_buf()\n  return new Uint32Array(wasmObj.memory.buffer, ptr, gpuThread * SIZE.CTX / 4)\n}\n\nexport function pbkdf2Pre(gpuThread: number, elemLen: number) {\n  wasmObj.pbkdf2_pre(gpuThread, elemLen)\n}\n\nexport function pbkdf2Post(gpuThread: number) {\n  wasmObj.pbkdf2_post(gpuThread)\n}\n","import {\n  SIZE,\n  NUM,\n  DecryptParams,\n  EncryptParams,\n  EncryptNode,\n\n  readCache,\n  writeCache,\n  aesEncrypt,\n  fillRandomBytes,\n  isPositiveInt,\n  isUint,\n  isPowerOf2,\n  indexBuf,\n  cloneBuf,\n  xorBuf,\n} from './util'\n\nimport * as encryptCpu from './encrypt-cpu'\nimport * as encryptWebGl from './encrypt-webgl'\nimport * as wasm from './wasm'\n\n\nexport type BenchmarkInfo = {\n  cpuThread: number\n  gpuThread: number\n  cpuHashPerSec: number\n  gpuHashPerSec: number\n}\nlet benchmarkInfo: BenchmarkInfo | undefined\n\nconst BENCHMARK_FILE = '/.timelock/benchmark.json'\n\n\nasync function readInfo() {\n  const res = await readCache(BENCHMARK_FILE)\n  if (!res) {\n    return\n  }\n  let info: BenchmarkInfo\n  try {\n    info = await res.json()\n  } catch {\n    console.warn('invalid benchmark cache')\n    return\n  }\n  if (typeof info === 'object' &&\n    isPositiveInt(info.cpuThread) &&\n    isPositiveInt(info.cpuHashPerSec) &&\n    isUint(info.gpuThread) &&\n    isUint(info.gpuHashPerSec)\n  ) {\n    return info\n  }\n}\n\nasync function saveInfo(info: BenchmarkInfo) {\n  const data = JSON.stringify(info)\n  await writeCache(BENCHMARK_FILE, data)\n}\n\n\nconst enum Status {\n  NONE,\n  INITING,\n  READY,\n  BENCHMARKING,\n  RUNNING,\n  PAUSED,\n}\nlet status: Status = Status.NONE\nlet gpuAvailable = true\n\n\nexport async function init() {\n  if (status !== Status.NONE) {\n    return\n  }\n  status = Status.INITING\n\n  await wasm.init()\n  const errMsg = await encryptWebGl.init()\n  if (errMsg) {\n    console.warn('init webgl error:', errMsg)\n    gpuAvailable = false\n  }\n  benchmarkInfo = await readInfo()\n\n  status = Status.READY\n}\n\nexport function isGpuAvailable() {\n  return gpuAvailable\n}\n\nexport async function benchmark(\n  onProgress: (info: BenchmarkInfo) => void\n) {\n  if (status !== Status.READY) {\n    return\n  }\n  status = Status.BENCHMARKING\n\n  const info: BenchmarkInfo = {\n    cpuThread: 0,\n    gpuThread: 0,\n    cpuHashPerSec: 0,\n    gpuHashPerSec: 0,\n  }\n\n  await encryptCpu.benchmark((iterPerMs, thread) => {\n    info.cpuHashPerSec = iterPerMs * 1000 * 2\n    info.cpuThread = thread\n    onProgress(info)\n  })\n\n  if (gpuAvailable) {\n    await encryptWebGl.benchmark((iterPerMs, thread) => {\n      info.gpuHashPerSec = iterPerMs * 1000 * 2\n      info.gpuThread = thread\n      onProgress(info)\n    })\n  }\n\n  await saveInfo(info)\n  benchmarkInfo = info\n\n  status = Status.READY\n}\n\nexport function getBenchmarkInfo() {\n  return benchmarkInfo\n}\n\nexport function pause() {\n  if (status !== Status.RUNNING) {\n    return\n  }\n  status = Status.PAUSED\n  encryptCpu.pause()\n  encryptWebGl.pause()\n}\n\nexport function resume() {\n  if (status !== Status.PAUSED) {\n    return\n  }\n  status = Status.RUNNING\n  encryptCpu.resume()\n  encryptWebGl.resume()\n}\n\nexport function stop() {\n  if (status !== Status.RUNNING) {\n    return\n  }\n  status = Status.READY\n  encryptCpu.stop()\n  encryptWebGl.stop()\n}\n\nexport async function start(\n  params: EncryptParams,\n  onProgress: (percent: number) => boolean\n) {\n  if (status !== Status.READY) {\n    throw Error('invalid status')\n  }\n  if (!benchmarkInfo) {\n    await benchmark(() => {})\n  }\n  status = Status.RUNNING\n\n  const plain = params.plain\n  const cost = params.cost\n  const seedLen = params.seedLen | 0\n\n  let cpuThread = params.cpuThread | 0\n  let gpuThread = params.gpuThread | 0\n\n  if (!gpuAvailable) {\n    gpuThread = 0\n  }\n  if (cpuThread < 0) {\n    throw Error('cpuThread must be >= 0')\n  }\n  if (gpuThread < 0) {\n    throw Error('gpuThread must be >= 0')\n  }\n  if (cpuThread + gpuThread === 0) {\n    throw Error('no available thread')\n  }\n  if (cost < 1) {\n    throw Error('cost must be >= 1')\n  }\n  if (seedLen <= 0 || seedLen > 32) {\n    throw Error('seedLen must in [1, 32]')\n  }\n\n  if (gpuThread && gpuThread < 32) {\n    gpuThread = 32\n  }\n  if (!isPowerOf2(gpuThread)) {\n    gpuThread = 1 << Math.log2(gpuThread)\n  }\n  if (cpuThread > 512) {\n    cpuThread = 512\n  }\n  if (gpuThread > 65536) {\n    gpuThread = 65536\n  }\n  const totalThread = gpuThread + cpuThread\n\n  // 1 cost = 1 Mhash\n  // 1 hash = 0.5 iter\n  const iter = Math.round(cost * 1e6 / 2)\n\n  const {cpuHashPerSec, gpuHashPerSec} = benchmarkInfo!\n  const cpuSpeedRatio = gpuThread\n    ? Math.round(cpuHashPerSec / gpuHashPerSec)\n    : 1\n\n  const sliceNum = gpuThread + cpuThread * cpuSpeedRatio\n  const iterPerSlice = Math.ceil(iter / sliceNum)\n\n  const seedsBuf = new Uint8Array(totalThread * seedLen)\n  fillRandomBytes(seedsBuf)\n\n  const encryptNodes: EncryptNode[] = []\n  const hashesBuf = new Uint8Array(totalThread * SIZE.HASH)\n  let gpuCrashed = false\n\n  // `iterRounded` is slightly larger than `iter`\n  const iterRounded = iterPerSlice * sliceNum\n  let iterCompleted = 0\n\n  const onIterAdded = (iterAdded: number) => {\n    iterCompleted += iterAdded\n    onProgress(iterCompleted / iterRounded)\n  }\n\n  const startGpuTask = async () => {\n    if (gpuThread === 0) {\n      return\n    }\n    console.time('gpu encryption')\n\n    const gpuSalt = wasm.getSaltBuf()\n    fillRandomBytes(gpuSalt)\n\n    const INTERVAL = 25\n    const iterPerMs = gpuHashPerSec / 1000 / 2\n    const iterPerDraw = iterPerMs * INTERVAL | 0\n\n    encryptWebGl.setIterPerDraw(iterPerDraw)\n    encryptWebGl.setThread(gpuThread)\n\n    const pbkdf2Ctx = wasm.getCtxBuf(gpuThread)\n    const gpuHashes = wasm.getHashesBuf(gpuThread)\n    const gpuSeeds = seedsBuf.subarray(0, seedLen * gpuThread)\n\n    gpuHashes.set(gpuSeeds)\n    wasm.pbkdf2Pre(gpuThread, seedLen)\n\n    let iterRemain = iterPerSlice\n\n    do {\n      // 1 iter has been performed at pbkdf2Pre\n      const gpuIter = Math.min(iterRemain, NUM.ITER_PER_LOOP) - 1\n      onIterAdded(gpuThread)\n\n      const ctxOut = await encryptWebGl.start(pbkdf2Ctx, gpuIter, onIterAdded)\n      if (!ctxOut) {\n        gpuCrashed = true\n        gpuAvailable = false\n        break\n      }\n      pbkdf2Ctx.set(ctxOut)\n      wasm.pbkdf2Post(gpuThread)\n\n      // next loop\n      wasm.pbkdf2Pre(gpuThread, SIZE.HASH)\n\n      iterRemain -= NUM.ITER_PER_LOOP\n    } while (iterRemain > 0)\n\n    console.timeEnd('gpu encryption')\n\n    if (gpuCrashed) {\n      if (cpuThread) {\n        encryptCpu.stop()\n      }\n      onProgress(-1)\n      return\n    }\n    encryptNodes[0] = {\n      name: 'GPU (WebGL)',\n      iter: iterPerSlice,\n      seedLen: seedLen,\n      seedNum: gpuThread,\n      seeds: gpuSeeds,\n      salt: cloneBuf(gpuSalt),\n    }\n    hashesBuf.set(gpuHashes)\n  }\n\n  const startCpuTask = async () => {\n    if (cpuThread === 0) {\n      return\n    }\n    console.time('cpu encryption')\n\n    const seedsBegin = seedLen * gpuThread\n    const seedsEnd = seedLen * (gpuThread + cpuThread)\n    const cpuSeeds = seedsBuf.subarray(seedsBegin, seedsEnd)\n\n    const cpuSalt = new Uint8Array(SIZE.SALT)\n    fillRandomBytes(cpuSalt)\n\n    const cpuIter = iterPerSlice * cpuSpeedRatio\n    const cpuHashes = await encryptCpu.start(\n      cpuThread,\n      cpuSeeds,\n      seedLen,\n      cpuSalt,\n      cpuIter,\n      onIterAdded,\n    )\n    console.timeEnd('cpu encryption')\n\n    // aborted\n    if (!cpuHashes) {\n      return\n    }\n    encryptNodes[1] = {\n      name: 'CPU (WebCrypto)',\n      iter: cpuIter,\n      seedNum: cpuThread,\n      seedLen: seedLen,\n      seeds: cpuSeeds,\n      salt: cpuSalt,\n    }\n    hashesBuf.set(cpuHashes, gpuThread * SIZE.HASH)\n  }\n\n  await Promise.all([\n    startGpuTask(),\n    startCpuTask(),\n  ])\n\n  if (gpuCrashed) {\n    status = Status.READY\n    return\n  }\n\n  // encrypt seeds\n  const key = new Uint8Array(SIZE.HASH)\n\n  for (let i = 0; i < totalThread; i++) {\n    const hash = indexBuf(hashesBuf, SIZE.HASH, i)\n    const seed = indexBuf(seedsBuf, seedLen, i)\n\n    xorBuf(seed, key, seedLen)\n    xorBuf(key, hash, SIZE.HASH)\n  }\n\n  const cipher = await aesEncrypt(plain, key, new Uint8Array(16))\n  const output: DecryptParams = {\n    cost,\n    cipher,\n    nodes: encryptNodes.filter(v => v),\n  }\n  status = Status.READY\n  return output\n}\n","import {\n  SIZE,\n  NUM,\n  DecryptParams,\n  xorBuf,\n  indexBuf,\n  aesDecrypt,\n  isPositiveInt,\n} from './util'\n\nlet isRunning: boolean\nlet isStopping: boolean\nlet pausedSignal: Promise<void> | undefined\nlet resumeCallback: () => void\n\n\nexport async function start(\n  params: DecryptParams,\n  onProgress: (percent: number, hashPerSec: number) => void\n) {\n  if (isRunning) {\n    throw Error('invalid status')\n  }\n  isRunning = true\n  isStopping = false\n\n  let completedIter = 0\n  let totalIter = 0\n\n  for (const item of params.nodes) {\n    const {iter, seedNum, seedLen, seeds} = item\n\n    if (!isPositiveInt(iter)) {\n      throw Error('iter must be a positive integer')\n    }\n    if (!isPositiveInt(seedLen)) {\n      throw Error('seedLen must be a positive integer')\n    }\n    if (!isPositiveInt(seedNum)) {\n      throw Error('thread must be a positive integer')\n    }\n    if (seeds.length !== seedLen * seedNum) {\n      throw Error('seeds.length != seedLen * thread')\n    }\n    totalIter += iter * seedNum\n  }\n\n  const pbkdfOpt: Pbkdf2Params = {\n    name: 'PBKDF2',\n    hash: 'SHA-256',\n    salt: undefined!,\n    iterations: 0,\n  }\n\n  const slowHash = async (seed: Uint8Array, iter: number) => {\n    const loop = Math.ceil(iter / NUM.ITER_PER_LOOP)\n\n    let hash = seed\n    let iterRemain = iter\n\n    for (let i = 0; i < loop; i++) {\n      pbkdfOpt.iterations = Math.min(iterRemain, NUM.ITER_PER_LOOP)\n      iterRemain -= NUM.ITER_PER_LOOP\n\n      const k = await crypto.subtle.importKey(\n        'raw', hash, 'PBKDF2', false, ['deriveBits']\n      )\n      const startTime = performance.now()\n      const buf = await crypto.subtle.deriveBits(pbkdfOpt, k, SIZE.HASH * 8)\n      const endTime = performance.now()\n\n      const time = endTime - startTime\n      const iterPerMs = pbkdfOpt.iterations / time\n      const hashPerSec = iterPerMs * 1000 * 2\n\n      hash = new Uint8Array(buf)\n\n      if (pausedSignal) {\n        await pausedSignal\n      }\n      if (isStopping) {\n        break\n      }\n      completedIter += pbkdfOpt.iterations\n      onProgress(completedIter / totalIter, hashPerSec)\n    }\n    return hash\n  }\n\n  // XOR'd with zero will be itself\n  const key = new Uint8Array(SIZE.HASH)\n\n  for (const item of params.nodes) {\n    const {iter, seedNum, seedLen, seeds, salt} = item\n\n    const saltIdBuf = new Uint8Array(salt.length + 4)\n    const saltIdView = new DataView(saltIdBuf.buffer)\n\n    saltIdBuf.set(salt)\n    pbkdfOpt.salt = saltIdBuf\n\n    for (let p = 0; p < seedNum; p++) {\n      saltIdView.setUint32(salt.length, p)\n\n      const seed = indexBuf(seeds, seedLen, p)\n      xorBuf(seed, key, seedLen)\n\n      const hash = await slowHash(seed, iter)\n      xorBuf(key, hash, SIZE.HASH)\n\n      if (isStopping) {\n        isRunning = false\n        return\n      }\n    }\n  }\n\n  try {\n    return await aesDecrypt(params.cipher, key, new Uint8Array(16))\n  } catch {\n  } finally {\n    isRunning = false\n  }\n}\n\nexport function pause() {\n  pausedSignal = new Promise(resolve => {\n    resumeCallback = resolve\n  })\n}\n\nexport function resume() {\n  pausedSignal = undefined\n  resumeCallback()\n}\n\nexport function stop() {\n  isStopping = true\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","fillRandomBytes","buf","i","length","slice","subarray","crypto","getRandomValues","xorBuf","dst","src","len","indexBuf","sliceLen","index","offset","cloneBuf","isUint","Math","floor","isPositiveInt","workerEnv","sendMsgToPage","postMessage","pausedSignal","resumeCallback","isStopping","self","onmessage","e","msg","data","type","async","seed","salt","iter","pbkdfOpt","name","hash","iterations","loop","ceil","iterRemain","min","k","subtle","importKey","deriveBits","Uint8Array","iterAdded","start","Promise","resolve","undefined","pwd","opt","startTime","performance","now","endTime","benchmark","MyWorker","Worker","threadId","constructor","url","super","sendMsg","workerPool","workerUrl","completedHashes","completedNum","threadNum","benchmarkInfo","benchmarkCallback","encryptOnComplete","encryptOnProgress","allocWorker","id","blob","Blob","URL","createObjectURL","worker","onWorkerMsg","sendMsgToWorkers","this","bufs","ret","pos","v","set","concatBuf","push","startTimeMin","map","endTimeMax","max","benchmarkThread","thread","p","stop","texW","gl","iterHandle","iterPerDraw","sleep","ms","fn","setTimeout","createShader","code","shader","Error","shaderSource","compileShader","getShaderParameter","getShaderInfoLog","setIterPerDraw","uniform1ui","setThread","viewport","outTex","createTexture","bindTexture","texImage2D","framebufferTexture2D","drawBuffers","inTex","texParameteri","write","texH","read","ptr","readBuffer","readPixels","draw","drawArrays","dstX","dstY","copyTexSubImage2D","errMsg","canvas","OffscreenCanvas","ctx","getContext","failIfMajorPerformanceCaveat","powerPreference","oncontextlost","console","warn","oncontextrestored","vertexData","Float32Array","bindBuffer","createBuffer","bufferData","program","createProgram","vertexShader","fragShader","replace","attachShader","linkProgram","useProgram","vertexAttribPointer","enableVertexAttribArray","getUniformLocation","frameBuffer","createFramebuffer","bindFramebuffer","initWebGl","err","message","init","params","ctxBuf","drawCount","backup","isContextLost","Uint32Array","timeMin","time","initCallback","benchmarkThreadCallback","completeCallback","progressCallback","sendMsgToWorker","onProgress","wasmObj","pbkdf2Pre","gpuThread","elemLen","pbkdf2_pre","pbkdf2Post","pbkdf2_post","BENCHMARK_FILE","isRunning","gpuAvailable","res","fetch","instance","WebAssembly","instantiateStreaming","cache","caches","open","match","readCache","info","json","cpuThread","cpuHashPerSec","gpuHashPerSec","readInfo","isGpuAvailable","PROBE_ITER","log","iterPerSec","singleThreadTime","iterPerMs","window","navigator","hardwareConcurrency","tryThread","ratio","multiThreadTime","JSON","stringify","Response","put","writeCache","saveInfo","getBenchmarkInfo","plain","cost","seedLen","log2","totalThread","round","cpuSpeedRatio","sliceNum","iterPerSlice","seedsBuf","encryptNodes","hashesBuf","gpuCrashed","iterRounded","iterCompleted","onIterAdded","all","gpuSalt","get_salt_buf","memory","buffer","pbkdf2Ctx","get_ctx_buf","gpuHashes","get_hashes_buf","gpuSeeds","gpuIter","ctxOut","timeEnd","seedNum","seeds","startGpuTask","seedsBegin","seedsEnd","cpuSeeds","cpuSalt","cpuIter","cpuHashes","saltBuf","saltIdBuf","saltIdView","DataView","setUint32","startCpuTask","cipher","iv","encrypt","aesEncrypt","output","nodes","filter","completedIter","totalIter","item","slowHash","hashPerSec","decrypt","aesDecrypt"],"sourceRoot":""}