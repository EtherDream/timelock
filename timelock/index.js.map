{"version":3,"file":"index.js","mappings":"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","sources":["webpack://timelock/webpack/bootstrap","webpack://timelock/webpack/runtime/define property getters","webpack://timelock/webpack/runtime/hasOwnProperty shorthand","webpack://timelock/webpack/runtime/make namespace object","webpack://timelock/./src/util.ts","webpack://timelock/./src/encrypt-cpu.ts","webpack://timelock/./src/encrypt-webgl.ts","webpack://timelock/./src/wasm.ts","webpack://timelock/./src/encrypt.ts","webpack://timelock/./src/decrypt.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const enum SIZE {\n  HASH = 32,\n  SALT = 12,\n  SALT_WITH_ID = SALT + 4,\n  PIXEL = 16,\n  CTX = 128,\n}\n\nexport const enum NUM {\n  ITER_PER_LOOP = 1e7\n}\n\nexport type EncryptParams = {\n  plain: Uint8Array\n  cost: number\n  seedLen: number\n  cpuThread: number\n  gpuThread: number\n}\n\nexport type EncryptNode = {\n  name: string\n  iter: number\n  seedNum: number\n  seedLen: number\n  seeds: Uint8Array\n  salt: Uint8Array\n}\n\nexport type DecryptParams = {\n  cost: number\n  cipher: Uint8Array\n  nodes: EncryptNode[]\n}\n\nexport async function aesEncrypt(plain: Uint8Array, key: Uint8Array, iv: Uint8Array) {\n  const k = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt'])\n  const buf = await crypto.subtle.encrypt({name: 'AES-GCM', iv}, k, plain)\n  return new Uint8Array(buf)\n}\n\nexport async function aesDecrypt(cipher: Uint8Array, key: Uint8Array, iv: Uint8Array) {\n  const k = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['decrypt'])\n  const buf = await crypto.subtle.decrypt({name: 'AES-GCM', iv}, k, cipher)\n  return new Uint8Array(buf)\n}\n\nexport function fillRandomBytes(buf: Uint8Array) {\n  for (let i = 0; i < buf.length; i += 65536) {\n    const slice = buf.subarray(i, i + 65536)\n    crypto.getRandomValues(slice)\n  }\n}\n\nexport function xorBuf(dst: Uint8Array, src: Uint8Array, len: number) {\n  for (let i = 0; i < len; i++) {\n    dst[i] ^= src[i]\n  }\n}\n\nexport function indexBuf(buf: Uint8Array, sliceLen: number, index: number) {\n  const offset = index * sliceLen\n  return buf.subarray(offset, offset + sliceLen)\n}\n\nexport function cloneBuf(buf: Uint8Array) {\n  return buf.slice(0)\n}\n\nexport function concatBuf(bufs: Uint8Array[], size: number) {\n  const ret = new Uint8Array(size)\n  let pos = 0\n  for (const v of bufs) {\n    ret.set(v, pos)\n    pos += v.length\n  }\n  return ret\n}\n\nexport function sleep(ms: number) {\n  return new Promise(fn => {\n    setTimeout(fn, ms)\n  })\n}\n\nexport function isUint(value: number) {\n  return value === Math.floor(value)\n}\n\nexport function isPositiveInt(value: number) {\n  return value > 0 && isUint(value)\n}\n\nexport function isPowerOf2(value: number) {\n  return (value & (value - 1)) === 0\n}\n\nexport async function readCache(url: string) {\n  const cache = await caches.open('timelock')\n  return await cache.match(url)\n}\n\nexport async function writeCache(url: string, data: BodyInit) {\n  const cache = await caches.open('timelock')\n  const res = new Response(data)\n  await cache.put(url, res)\n}\n","import {\n  SIZE,\n  NUM,\n  indexBuf,\n  cloneBuf,\n  concatBuf,\n} from './util'\n\n//\n// page to worker message\n//\nconst enum ReqMsgType {\n  START,\n  STOP,\n  PAUSE,\n  RESUME,\n  BENCHMARK,\n}\ntype ReqMsgStart = {\n  type: ReqMsgType.START\n  seed: Uint8Array\n  salt: Uint8Array\n  iter: number\n}\ntype ReqMsgStop = {\n  type: ReqMsgType.STOP\n}\ntype ReqMsgPause = {\n  type: ReqMsgType.PAUSE\n}\ntype ReqMsgResume = {\n  type: ReqMsgType.RESUME\n}\ntype ReqMsgBenchmark = {\n  type: ReqMsgType.BENCHMARK\n  iter: number\n}\ntype ReqMsg =\n  ReqMsgStart | ReqMsgStop | ReqMsgPause | ReqMsgResume | ReqMsgBenchmark\n\n//\n// worker to page message\n//\nconst enum ResMsgType {\n  PROGRESS,\n  COMPLETE,\n  STOPPED,\n  BENCHMARK,\n}\ntype ResMsgProgress = {\n  type: ResMsgType.PROGRESS\n  iterAdded: number\n}\ntype ResMsgComplete = {\n  type: ResMsgType.COMPLETE\n  hash: Uint8Array\n}\ntype ResMsgStopped = {\n  type: ResMsgType.STOPPED\n}\ntype ResMsgBenchmark = {\n  type: ResMsgType.BENCHMARK\n  startTime: number\n  endTime: number\n}\ntype ResMsg =\n  ResMsgProgress | ResMsgComplete | ResMsgStopped | ResMsgBenchmark\n\n//\n// this function will be run in the worker context\n//\nconst workerEnv = () => {\n  const sendMsgToPage: ((msg: ResMsg) => void) = postMessage\n\n  let pausedSignal: Promise<void> | undefined\n  let resumeCallback: () => void\n  let isStopping: boolean\n\n\n  async function start(params: ReqMsgStart) {\n    isStopping = false\n\n    const {seed, salt, iter} = params\n    const loop = Math.ceil(iter / NUM.ITER_PER_LOOP)\n\n    const pbkdfOpt: Pbkdf2Params = {\n      name: 'PBKDF2',\n      hash: 'SHA-256',\n      salt,\n      iterations: 0,\n    }\n    let hash = seed\n    let iterRemain = iter\n\n    for (let i = 0; i < loop; i++) {\n      pbkdfOpt.iterations = Math.min(iterRemain, NUM.ITER_PER_LOOP)\n      iterRemain -= NUM.ITER_PER_LOOP\n\n      const k = await crypto.subtle.importKey(\n        'raw', hash, 'PBKDF2', false, ['deriveBits']\n      )\n      const buf = await crypto.subtle.deriveBits(pbkdfOpt, k, SIZE.HASH * 8)\n      hash = new Uint8Array(buf)\n\n      if (pausedSignal) {\n        await pausedSignal\n      }\n      if (isStopping) {\n        sendMsgToPage({\n          type: ResMsgType.STOPPED,\n        })\n        return\n      }\n      sendMsgToPage({\n        type: ResMsgType.PROGRESS,\n        iterAdded: pbkdfOpt.iterations,\n      })\n    }\n    sendMsgToPage({\n      type: ResMsgType.COMPLETE,\n      hash,\n    })\n  }\n\n  async function benchmark(iter: number) {\n    const pwd = crypto.getRandomValues(new Uint8Array(32))\n    const opt: Pbkdf2Params = {\n      name: 'PBKDF2',\n      hash: 'SHA-256',\n      salt: new Uint8Array(16),\n      iterations: iter,\n    }\n    const key = await crypto.subtle.importKey(\n      'raw', pwd, 'PBKDF2', false, ['deriveBits']\n    )\n    const startTime = performance.now()\n    await crypto.subtle.deriveBits(opt, key, SIZE.HASH * 8)\n    const endTime = performance.now()\n\n    sendMsgToPage({\n      type: ResMsgType.BENCHMARK,\n      startTime,\n      endTime,\n    })\n  }\n\n\n  self.onmessage = (e) => {\n    const msg: ReqMsg = e.data\n\n    switch (msg.type) {\n    case ReqMsgType.START:\n      start(msg)\n      break\n    case ReqMsgType.STOP:\n      isStopping = true\n      break\n    case ReqMsgType.PAUSE:\n      pausedSignal = new Promise(resolve => {\n        resumeCallback = resolve\n      })\n      break\n    case ReqMsgType.RESUME:\n      resumeCallback()\n      pausedSignal = undefined\n      break\n    case ReqMsgType.BENCHMARK:\n      benchmark(msg.iter)\n      break\n    }\n  }\n}\n\nclass MyWorker extends Worker {\n  constructor(url: string, public threadId: number) {\n    super(url)\n  }\n  sendMsg(msg: ReqMsg) {\n    super.postMessage(msg)\n  }\n}\n\nconst workerPool: MyWorker[] = []\nlet workerUrl: string\n\n\nfunction allocWorker(id: number) {\n  if (!workerUrl) {\n    const code = '(' + workerEnv + ')()'\n    const blob = new Blob([code])\n    workerUrl = URL.createObjectURL(blob)\n  }\n  let worker = workerPool[id]\n  if (!worker) {\n    worker = new MyWorker(workerUrl, id)\n    worker.onmessage = onWorkerMsg\n    workerPool[id] = worker\n  }\n  return worker\n}\n\n\nlet completedHashes: Uint8Array[]\nlet completedNum: number\nlet threadNum: number\n\nlet benchmarkInfo: ResMsgBenchmark[]\nlet benchmarkCallback: (time: number) => void\n\n\nfunction sendMsgToWorkers(msg: ReqMsg) {\n  for (let i = 0; i < threadNum; i++) {\n    workerPool[i].sendMsg(msg)\n  }\n}\n\nfunction onWorkerMsg(this: Worker, e: MessageEvent) {\n  const {threadId} = this as MyWorker\n  const msg: ResMsg = e.data\n\n  switch (msg.type) {\n  case ResMsgType.PROGRESS:\n    encryptOnProgress(msg.iterAdded)\n    break\n  case ResMsgType.COMPLETE:\n    completedHashes[threadId] = msg.hash\n    if (++completedNum === threadNum) {\n      const buf = concatBuf(completedHashes, threadNum * SIZE.HASH)\n      encryptOnComplete(buf)\n    }\n    break\n  case ResMsgType.STOPPED:\n    encryptOnComplete()\n    break\n  case ResMsgType.BENCHMARK:\n    if (benchmarkInfo.push(msg) === threadNum) {\n      const startTimeMin = Math.min(...benchmarkInfo.map(v => v.startTime))\n      const endTimeMax = Math.max(...benchmarkInfo.map(v => v.endTime))\n      const totalTime = endTimeMax - startTimeMin\n      benchmarkCallback(totalTime)\n    }\n    break\n  }\n}\n\nfunction benchmarkThread(thread: number, iter: number) {\n  threadNum = thread\n  benchmarkInfo = []\n\n  for (let p = 0; p < thread; p++) {\n    const worker = allocWorker(p)\n    worker.sendMsg({\n      type: ReqMsgType.BENCHMARK,\n      iter,\n    })\n  }\n  return new Promise<number>(resolve => {\n    benchmarkCallback = resolve\n  })\n}\n\n\nexport async function benchmark(\n  onProgress: (iterPerMs: number, thread: number) => void\n) {\n  const MAX_LOSS_RATIO = 1.2\n  const PROBE_ITER = 2e6\n  const THREAD_GROW = 1.2\n\n  console.log('evaluating CPU single thread performance...')\n\n  const probeTime = await benchmarkThread(1, PROBE_ITER)\n  const iterPerSec = PROBE_ITER / probeTime * 1000 | 0\n\n  const singleThreadTime = await benchmarkThread(1, iterPerSec)\n  const iterPerMs = iterPerSec / singleThreadTime | 0\n\n  console.log('speed: ~' + iterPerMs + ' iter/ms')\n\n  console.log('estimating CPU thread count...')\n  let thread = 1\n\n  if ('safari' in window) {\n    thread = navigator.hardwareConcurrency\n  }\n\n  for (;;) {\n    const tryThread = Math.ceil(thread * THREAD_GROW)\n    // init worker\n    await benchmarkThread(tryThread, 1)\n\n    const totalTime = await benchmarkThread(tryThread, iterPerSec)\n    const ratio = totalTime / singleThreadTime\n\n    onProgress(iterPerMs, tryThread)\n    console.log('try thread:', tryThread, 'ratio:', ratio)\n\n    if (ratio > MAX_LOSS_RATIO) {\n      break\n    }\n    thread = tryThread\n  }\n  onProgress(iterPerMs, thread)\n}\n\n\nlet encryptOnComplete: (hashes?: Uint8Array) => void\nlet encryptOnProgress: (iterAdded: number) => void\n\nexport function start(\n  thread: number,\n  seedsBuf: Uint8Array,\n  seedLen: number,\n  saltBuf: Uint8Array,\n  iter: number,\n  onProgress: typeof encryptOnProgress,\n) {\n  threadNum = thread\n  completedHashes = []\n  completedNum = 0\n  encryptOnProgress = onProgress\n\n  const saltIdBuf = new Uint8Array(SIZE.SALT_WITH_ID)\n  const saltIdView = new DataView(saltIdBuf.buffer)\n  saltIdBuf.set(saltBuf)\n\n  for (let p = 0; p < thread; p++) {\n    const seed = indexBuf(seedsBuf, seedLen, p)\n    saltIdView.setUint32(SIZE.SALT, p)\n\n    const worker = allocWorker(p)\n    worker.sendMsg({\n      type: ReqMsgType.START,\n      seed: cloneBuf(seed),\n      salt: saltIdBuf,\n      iter,\n    })\n  }\n  return new Promise<Uint8Array | undefined>(resolve => {\n    encryptOnComplete = resolve\n  })\n}\n\nexport function stop() {\n  sendMsgToWorkers({\n    type: ReqMsgType.STOP,\n  })\n}\n\nexport function pause() {\n  sendMsgToWorkers({\n    type: ReqMsgType.PAUSE,\n  })\n}\n\nexport function resume() {\n  sendMsgToWorkers({\n    type: ReqMsgType.RESUME,\n  })\n}\n","import {WebGL2Const as GL} from './webgl-const'\nimport {SIZE} from './util'\nimport FRAG_SHADER from './assets/shader.glsl'\n\n//\n// page to worker message\n//\nconst enum ReqMsgType {\n  INIT,\n  START,\n  STOP,\n  PAUSE,\n  RESUME,\n  SET_ITER_PER_DRAW,\n  SET_THREAD,\n  BENCHMARK,\n}\ntype ReqMsgInit = {\n  type: ReqMsgType.INIT\n  shader: string\n}\ntype ReqMsgStart = {\n  type: ReqMsgType.START\n  ctxBuf: Uint32Array\n  iter: number\n}\ntype ReqMsgStop = {\n  type: ReqMsgType.STOP\n}\ntype ReqMsgPause = {\n  type: ReqMsgType.PAUSE\n}\ntype ReqMsgResume = {\n  type: ReqMsgType.RESUME\n}\ntype ReqMsgSetIterPerDraw = {\n  type: ReqMsgType.SET_ITER_PER_DRAW\n  iter: number\n}\ntype ReqMsgSetThread = {\n  type: ReqMsgType.SET_THREAD\n  thread: number\n}\ntype ReqMsgBenchmark = {\n  type: ReqMsgType.BENCHMARK\n  iter: number\n  thread: number\n}\ntype ReqMsg =\n  ReqMsgInit | ReqMsgStart | ReqMsgStop | ReqMsgPause | ReqMsgResume |\n  ReqMsgSetIterPerDraw | ReqMsgSetThread | ReqMsgBenchmark\n\n//\n// worker to page message\n//\nconst enum ResMsgType {\n  BENCHMARK,\n  PROGRESS,\n  COMPLETE,\n  INIT,\n}\ntype ResMsgProgress = {\n  type: ResMsgType.PROGRESS\n  iterAdded: number\n}\ntype ResMsgComplete = {\n  type: ResMsgType.COMPLETE\n  ctxBuf: Uint32Array\n}\ntype ResMsgBenchmark = {\n  type: ResMsgType.BENCHMARK\n  time: number\n}\ntype ResMsgInit = {\n  type: ResMsgType.INIT\n  errMsg: string\n}\ntype ResMsg =\n  ResMsgInit | ResMsgProgress | ResMsgComplete | ResMsgBenchmark\n\n//\n// this function will be run in the worker context\n//\nconst workerEnv = () => {\n  const sendMsgToPage: ((msg: ResMsg) => void) = postMessage\n\n  // \"Transform Feedback\" is simpler, but crashes frequently,\n  // so we still use the GPGPU solution of WebGL1.\n\n  // colors per thread\n  const IN_COLOR_NUM = 8\n  const OUT_COLOR_NUM = 4\n\n  //\n  // threadNum = texW * texH\n  //\n  // inTex:\n  //\n  // |----------- texW ------------|\n  // |             Ra             texH\n  // |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n  // |             Rb             texH\n  // |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n  // |            ....             |\n  // |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|\n  // |             Ob             texH\n  // |-----------------------------|\n  // (Ra, Rb, Wa, Wb, Ia, Ib, Oa, Ob)\n  //\n  //\n  // outTex:\n  //\n  // color_attachment0\n  // |----------- texW ------------|\n  // |             Ra             texH\n  // |-----------------------------|\n  //\n  // color_attachment1\n  // |----------- texW ------------|\n  // |             Rb             texH\n  // |-----------------------------|\n  //\n  // color_attachment2\n  // |----------- texW ------------|\n  // |             Wa             texH\n  // |-----------------------------|\n  //\n  // color_attachment3\n  // |----------- texW ------------|\n  // |             Wb             texH\n  // |-----------------------------|\n  //\n  const texH = 4\n  let texW: number\n\n  let gl: WebGL2RenderingContext\n  let iterHandle: WebGLUniformLocation\n  let iterPerDraw: number\n  let threadNum: number\n\n  let isStopping: boolean\n  let pausedSignal: Promise<void> | undefined\n  let resumeCallback: () => void\n\n\n  function sleep(ms: number) {\n    return new Promise(fn => {\n      setTimeout(fn, ms)\n    })\n  }\n\n  function createShader(code: string, type: number) {\n    const shader = gl.createShader(type)\n    if (!shader) {\n      throw Error('createShader failed')\n    }\n    gl.shaderSource(shader, code)\n    gl.compileShader(shader)\n\n    if (!gl.getShaderParameter(shader, GL.COMPILE_STATUS)) {\n      const msg = gl.getShaderInfoLog(shader)!\n      throw Error(msg)\n    }\n    return shader\n  }\n\n  function initWebGl(shader: string) {\n    const canvas = new OffscreenCanvas(0, 0)\n\n    const ctx = canvas.getContext('webgl2', {\n      failIfMajorPerformanceCaveat: true,\n      powerPreference: 'high-performance',\n    })\n    if (!ctx) {\n      throw Error('webgl2 is not available')\n    }\n    gl = ctx\n\n    canvas.oncontextlost = () => {\n      console.warn('webgl oncontextlost')\n    }\n    canvas.oncontextrestored = () => {\n      console.warn('webgl oncontextrestored')\n    }\n\n    const vertexData = new Float32Array([\n      -1, +1, // left top\n      -1, -1, // left bottom\n      +1, +1, // right top\n      +1, -1, // right bottom\n    ])\n    gl.bindBuffer(GL.ARRAY_BUFFER, gl.createBuffer())\n    gl.bufferData(GL.ARRAY_BUFFER, vertexData, GL.STATIC_DRAW)\n\n    const program = gl.createProgram()\n    if (!program) {\n      throw Error('createProgram failed')\n    }\n    const VERTEX_SHADER = `\\\n#version 300 es\nin vec2 v_pos;\nvoid main() {\n  gl_Position = vec4(v_pos, 0., 1.);\n}`\n    const vertexShader = createShader(VERTEX_SHADER, GL.VERTEX_SHADER)\n\n    const fragShaderCode = shader.replace('__TEX_H__', texH + 'u')\n    const fragShader = createShader(fragShaderCode, GL.FRAGMENT_SHADER)\n\n    gl.attachShader(program, fragShader)\n    gl.attachShader(program, vertexShader)\n\n    gl.linkProgram(program)\n    gl.useProgram(program)\n\n    const posHandle = 0\n    gl.vertexAttribPointer(posHandle, 2 /*vec2*/, GL.FLOAT, false, 0, 0)\n    gl.enableVertexAttribArray(posHandle)\n\n    iterHandle = gl.getUniformLocation(program, 'in_iter')!\n\n    const frameBuffer = gl.createFramebuffer()\n    if (!frameBuffer) {\n      throw Error('createFramebuffer failed')\n    }\n    gl.bindFramebuffer(GL.FRAMEBUFFER, frameBuffer)\n  }\n\n  function setIterPerDraw(value: number) {\n    if (iterPerDraw === value) {\n      return\n    }\n    iterPerDraw = value\n\n    // 1x iter => 2x hash\n    gl.uniform1ui(iterHandle, value * 2)\n  }\n\n  function setThread(thread: number) {\n    if (threadNum === thread) {\n      return\n    }\n    threadNum = thread\n\n    // threadNum is a power of 2\n    texW = threadNum / texH\n    gl.viewport(0, 0, texW, texH)\n\n    for (let i = 0; i < OUT_COLOR_NUM; i++) {\n      const outTex = gl.createTexture()\n      if (!outTex) {\n        throw Error('create outTex failed')\n      }\n      gl.bindTexture(GL.TEXTURE_2D, outTex)\n\n      gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA32UI, texW, texH,\n        0, GL.RGBA_INTEGER, GL.UNSIGNED_INT, null)\n\n      gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0 + i,\n        GL.TEXTURE_2D, outTex, 0)\n    }\n\n    gl.drawBuffers([\n      GL.COLOR_ATTACHMENT0, GL.COLOR_ATTACHMENT1,\n      GL.COLOR_ATTACHMENT2, GL.COLOR_ATTACHMENT3,\n    ])\n\n    const inTex = gl.createTexture()\n    if (!inTex) {\n      throw Error('create inTex failed')\n    }\n    gl.bindTexture(GL.TEXTURE_2D, inTex)\n    gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST)\n    gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST)\n  }\n\n  function write(buf: Uint32Array) {\n    gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA32UI, texW, texH * IN_COLOR_NUM,\n      0, GL.RGBA_INTEGER, GL.UNSIGNED_INT, buf)\n  }\n\n  function read(buf: Uint32Array) {\n    for (let i = 0; i < OUT_COLOR_NUM; i++) {\n      const ptr = i * threadNum * SIZE.PIXEL\n\n      gl.readBuffer(GL.COLOR_ATTACHMENT0 + i)\n      gl.readPixels(0, 0, texW, texH,\n        GL.RGBA_INTEGER, GL.UNSIGNED_INT, buf, ptr / 4)\n    }\n  }\n\n  function draw() {\n    gl.drawArrays(GL.TRIANGLE_STRIP, 0, 4)\n\n    // copy outTex[i] to inTex at P(0, i * texH)\n    for (let i = 0; i < OUT_COLOR_NUM; i++) {    \n      const dstX = 0\n      const dstY = i * texH\n\n      gl.readBuffer(GL.COLOR_ATTACHMENT0 + i)\n      gl.copyTexSubImage2D(GL.TEXTURE_2D, 0, dstX, dstY, 0, 0, texW, texH)\n    }\n  }\n\n  async function benchmark(thread: number, iter: number) {\n    setThread(thread)\n    setIterPerDraw(iter)\n\n    const ctxBuf = new Uint32Array(thread * IN_COLOR_NUM * SIZE.PIXEL / 4)\n    write(ctxBuf)\n\n    const SAMPLE_NUM = 30\n    let timeMin = 1e9\n\n    for (let i = 0; i < SAMPLE_NUM; i++) {\n      const startTime = performance.now()\n      draw()\n      read(ctxBuf)\n      const endTime = performance.now()\n\n      const time = endTime - startTime\n      if (time < timeMin) {\n        timeMin = time\n      }\n      if (time < 16) {\n        break\n      }\n      await sleep(1)\n    }\n\n    sendMsgToPage({\n      type: ResMsgType.BENCHMARK,\n      time: timeMin,\n    })\n  }\n\n\n  const DRAWS_PER_SYNC = 10\n\n  async function start(params: ReqMsgStart) {\n    isStopping = false\n\n    const {ctxBuf, iter} = params\n    write(ctxBuf)\n\n    let iterRemain = iter\n    let iterAdded = 0\n    let drawCount = 0\n\n    for (;;) {\n      if (iterRemain <= iterPerDraw) {\n        const backup = iterPerDraw\n        setIterPerDraw(iterRemain)\n        draw()\n        setIterPerDraw(backup)\n\n        iterAdded += iterRemain * threadNum\n        sendMsgToPage({\n          type: ResMsgType.PROGRESS,\n          iterAdded,\n        })\n        break\n      }\n      draw()\n      iterRemain -= iterPerDraw\n      iterAdded += iterPerDraw * threadNum\n\n      // TODO: WebGLSync\n      if (++drawCount === DRAWS_PER_SYNC) {\n        drawCount = 0\n        read(ctxBuf)\n\n        sendMsgToPage({\n          type: ResMsgType.PROGRESS,\n          iterAdded,\n        })\n        iterAdded = 0\n        await sleep(1)\n\n        if (pausedSignal) {\n          await pausedSignal\n        }\n        if (isStopping) {\n          return\n        }\n      }\n    }\n    if (gl.isContextLost()) {\n      sendMsgToPage({\n        type: ResMsgType.PROGRESS,\n        iterAdded: -1,\n      })\n      return\n    }\n    read(ctxBuf)\n    sendMsgToPage({\n      type: ResMsgType.COMPLETE,\n      ctxBuf,\n    })\n  }\n\n  function init(shader: string) {\n    let errMsg = ''\n    try {\n      initWebGl(shader)\n    } catch (err: any) {\n      errMsg = err.message\n    }\n    sendMsgToPage({\n      type: ResMsgType.INIT,\n      errMsg,\n    })\n  }\n\n\n  self.onmessage = (e) => {\n    const msg: ReqMsg = e.data\n\n    switch (msg.type) {\n    case ReqMsgType.INIT:\n      init(msg.shader)\n      break\n    case ReqMsgType.START:\n      start(msg)\n      break\n    case ReqMsgType.STOP:\n      isStopping = true\n      break\n    case ReqMsgType.PAUSE:\n      pausedSignal = new Promise(resolve => {\n        resumeCallback = resolve\n      })\n      break\n    case ReqMsgType.RESUME:\n      resumeCallback()\n      pausedSignal = undefined\n      break\n    case ReqMsgType.SET_ITER_PER_DRAW:\n      setIterPerDraw(msg.iter)\n      break\n    case ReqMsgType.SET_THREAD:\n      setThread(msg.thread)\n      break\n    case ReqMsgType.BENCHMARK:\n      benchmark(msg.thread, msg.iter)\n      break\n    }\n  }\n}\n\n\nlet worker: Worker\n\nfunction sendMsgToWorker(msg: ReqMsg) {\n  worker.postMessage(msg)\n}\n\nfunction onWorkerMsg(e: MessageEvent) {\n  const msg: ResMsg = e.data\n\n  switch (msg.type) {\n  case ResMsgType.INIT:\n    initCallback(msg.errMsg)\n    break\n  case ResMsgType.PROGRESS:\n    if (msg.iterAdded === -1) {\n      completeCallback()\n    } else {\n      progressCallback(msg.iterAdded)\n    }\n    break\n  case ResMsgType.COMPLETE:\n    completeCallback(msg.ctxBuf)\n    break\n  case ResMsgType.BENCHMARK:\n    benchmarkThreadCallback(msg.time)\n    break\n  }\n}\n\nlet initCallback: (err: string) => void\n\nexport function init() {\n  const code = '(' + workerEnv + ')()'\n  const blob = new Blob([code])\n  const workerUrl = URL.createObjectURL(blob)\n\n  worker = new Worker(workerUrl)\n  worker.onmessage = onWorkerMsg\n\n  sendMsgToWorker({\n    type: ReqMsgType.INIT,\n    shader: FRAG_SHADER,\n  })\n  return new Promise<string>(resolve => {\n    initCallback = resolve\n  })\n}\n\n\nlet benchmarkThreadCallback: (time: number) => void\n\nfunction benchmarkThread(thread: number, iter: number) {\n  sendMsgToWorker({\n    type: ReqMsgType.BENCHMARK,\n    iter,\n    thread,\n  })\n  return new Promise<number>(resolve => {\n    benchmarkThreadCallback = resolve\n  })\n}\n\nexport async function benchmark(\n  onProgress: (iterPerMs: number, thread: number) => void\n) {\n  let iter = 256\n  let thread = 256\n\n  let singleThreadTime: number\n  console.log('evaluating GPU single thread performance...')\n\n  for (;;) {\n    setIterPerDraw(iter)\n    singleThreadTime = await benchmarkThread(thread, iter)\n\n    onProgress(iter / singleThreadTime | 0, thread)\n    console.log('try iter:', iter, 'time:', singleThreadTime)\n\n    if (singleThreadTime > 17) {\n      break\n    }\n    iter = iter * 1.25 | 0\n  }\n\n  let multiThreadTime = singleThreadTime\n  console.log('estimating GPU thread count...')\n\n  for (;;) {\n    const tryThread = thread * 2\n    const time = await benchmarkThread(tryThread, iter)\n    if (time < 10) {\n      console.warn('webgl crashed')\n      multiThreadTime = -1\n      break\n    }\n    if (time < singleThreadTime) {\n      singleThreadTime = time\n    }\n    const ratio = time / singleThreadTime\n    onProgress(iter / time | 0, tryThread)\n\n    console.log('try thread:', tryThread, 'ratio:', ratio)\n    if (ratio >= 1.9) {\n      break\n    }\n    thread = tryThread\n    multiThreadTime = time\n  }\n\n  onProgress(iter / multiThreadTime | 0, thread)\n}\n\n\nlet completeCallback: (ctxBuf?: Uint32Array) => void\nlet progressCallback: (iterAdded: number) => void\n\nexport function start(\n  ctxBuf: Uint32Array,\n  iter: number,\n  onProgress: typeof progressCallback,\n) {\n  progressCallback = onProgress\n\n  sendMsgToWorker({\n    type: ReqMsgType.START,\n    ctxBuf: ctxBuf.slice(0),\n    iter,\n  })\n  return new Promise<Uint32Array | undefined>(resolve => {\n    completeCallback = resolve\n  })\n}\n\nexport function stop() {\n  sendMsgToWorker({\n    type: ReqMsgType.STOP,\n  })\n}\n\nexport function pause() {\n  sendMsgToWorker({\n    type: ReqMsgType.PAUSE,\n  })\n}\n\nexport function resume() {\n  sendMsgToWorker({\n    type: ReqMsgType.RESUME,\n  })\n}\n\nexport function setIterPerDraw(value: number) {\n  sendMsgToWorker({\n    type: ReqMsgType.SET_ITER_PER_DRAW,\n    iter: value,\n  })\n}\n\nexport function setThread(value: number) {\n  sendMsgToWorker({\n    type: ReqMsgType.SET_THREAD,\n    thread: value,\n  })\n}\n","import {SIZE} from './util'\nimport WASM_URI from './assets/timelock.wasm'\n\n\nlet wasmObj: {\n  memory: WebAssembly.Memory\n\n  get_hashes_buf: () => number\n  get_salt_buf: () => number\n  get_ctx_buf: () => number\n  pbkdf2_pre: (gpu_thread: number, elem_len: number) => void\n  pbkdf2_post: (gpu_thread: number) => void\n}\n\nexport async function init() {\n  const res = await fetch(WASM_URI)\n  const {instance} = await WebAssembly.instantiateStreaming(res)\n  wasmObj = instance.exports as any\n}\n\nexport function getSaltBuf() {\n  const ptr = wasmObj.get_salt_buf()\n  return new Uint8Array(wasmObj.memory.buffer, ptr, SIZE.SALT)\n}\n\nexport function getHashesBuf(thread: number) {\n  const ptr = wasmObj.get_hashes_buf()\n  return new Uint8Array(wasmObj.memory.buffer, ptr, thread * SIZE.HASH)\n}\n\nexport function getCtxBuf(gpuThread: number) {\n  const ptr = wasmObj.get_ctx_buf()\n  return new Uint32Array(wasmObj.memory.buffer, ptr, gpuThread * SIZE.CTX / 4)\n}\n\nexport function pbkdf2Pre(gpuThread: number, elemLen: number) {\n  wasmObj.pbkdf2_pre(gpuThread, elemLen)\n}\n\nexport function pbkdf2Post(gpuThread: number) {\n  wasmObj.pbkdf2_post(gpuThread)\n}\n","import {\n  SIZE,\n  NUM,\n  DecryptParams,\n  EncryptParams,\n  EncryptNode,\n\n  readCache,\n  writeCache,\n  aesEncrypt,\n  fillRandomBytes,\n  isPositiveInt,\n  isUint,\n  isPowerOf2,\n  indexBuf,\n  cloneBuf,\n  xorBuf,\n} from './util'\n\nimport * as encryptCpu from './encrypt-cpu'\nimport * as encryptWebGl from './encrypt-webgl'\nimport * as wasm from './wasm'\n\n\nexport type BenchmarkInfo = {\n  cpuThread: number\n  gpuThread: number\n  cpuHashPerSec: number\n  gpuHashPerSec: number\n}\nlet benchmarkInfo: BenchmarkInfo | undefined\n\nconst BENCHMARK_FILE = '/.timelock/benchmark.json'\n\n\nasync function readInfo() {\n  const res = await readCache(BENCHMARK_FILE)\n  if (!res) {\n    return\n  }\n  let info: BenchmarkInfo\n  try {\n    info = await res.json()\n  } catch {\n    console.warn('invalid benchmark cache')\n    return\n  }\n  if (typeof info === 'object' &&\n    isPositiveInt(info.cpuThread) &&\n    isPositiveInt(info.cpuHashPerSec) &&\n    isUint(info.gpuThread) &&\n    isUint(info.gpuHashPerSec)\n  ) {\n    return info\n  }\n}\n\nasync function saveInfo(info: BenchmarkInfo) {\n  const data = JSON.stringify(info)\n  await writeCache(BENCHMARK_FILE, data)\n}\n\n\nconst enum Status {\n  NONE,\n  INITING,\n  READY,\n  BENCHMARKING,\n  RUNNING,\n  PAUSED,\n}\nlet status: Status = Status.NONE\nlet gpuAvailable = true\n\n\nexport async function init() {\n  if (status !== Status.NONE) {\n    return\n  }\n  status = Status.INITING\n\n  await wasm.init()\n  const errMsg = await encryptWebGl.init()\n  if (errMsg) {\n    console.warn('init webgl error:', errMsg)\n    gpuAvailable = false\n  }\n  benchmarkInfo = await readInfo()\n\n  status = Status.READY\n}\n\nexport function isGpuAvailable() {\n  return gpuAvailable\n}\n\nexport async function benchmark(\n  onProgress: (info: BenchmarkInfo) => void\n) {\n  if (status !== Status.READY) {\n    return\n  }\n  status = Status.BENCHMARKING\n\n  const info: BenchmarkInfo = {\n    cpuThread: 0,\n    gpuThread: 0,\n    cpuHashPerSec: 0,\n    gpuHashPerSec: 0,\n  }\n\n  await encryptCpu.benchmark((iterPerMs, thread) => {\n    info.cpuHashPerSec = iterPerMs * 1000 * 2\n    info.cpuThread = thread\n    onProgress(info)\n  })\n\n  if (gpuAvailable) {\n    await encryptWebGl.benchmark((iterPerMs, thread) => {\n      info.gpuHashPerSec = iterPerMs * 1000 * 2\n      info.gpuThread = thread\n      onProgress(info)\n    })\n  }\n\n  await saveInfo(info)\n  benchmarkInfo = info\n\n  status = Status.READY\n}\n\nexport function getBenchmarkInfo() {\n  return benchmarkInfo\n}\n\nexport function pause() {\n  if (status !== Status.RUNNING) {\n    return\n  }\n  status = Status.PAUSED\n  encryptCpu.pause()\n  encryptWebGl.pause()\n}\n\nexport function resume() {\n  if (status !== Status.PAUSED) {\n    return\n  }\n  status = Status.RUNNING\n  encryptCpu.resume()\n  encryptWebGl.resume()\n}\n\nexport function stop() {\n  if (status !== Status.RUNNING) {\n    return\n  }\n  status = Status.READY\n  encryptCpu.stop()\n  encryptWebGl.stop()\n}\n\nexport async function start(\n  params: EncryptParams,\n  onProgress: (percent: number) => boolean\n) {\n  if (status !== Status.READY) {\n    throw Error('invalid status')\n  }\n  if (!benchmarkInfo) {\n    await benchmark(() => {})\n  }\n  status = Status.RUNNING\n\n  const plain = params.plain\n  const cost = params.cost\n  const seedLen = params.seedLen | 0\n\n  let cpuThread = params.cpuThread | 0\n  let gpuThread = params.gpuThread | 0\n\n  if (!gpuAvailable) {\n    gpuThread = 0\n  }\n  if (cpuThread < 0) {\n    throw Error('cpuThread must be >= 0')\n  }\n  if (gpuThread < 0) {\n    throw Error('gpuThread must be >= 0')\n  }\n  if (cpuThread + gpuThread === 0) {\n    throw Error('no available thread')\n  }\n  if (cost < 1) {\n    throw Error('cost must be >= 1')\n  }\n  if (seedLen <= 0 || seedLen > 32) {\n    throw Error('seedLen must in [1, 32]')\n  }\n\n  if (gpuThread && gpuThread < 32) {\n    gpuThread = 32\n  }\n  if (!isPowerOf2(gpuThread)) {\n    gpuThread = 1 << Math.log2(gpuThread)\n  }\n  if (cpuThread > 512) {\n    cpuThread = 512\n  }\n  if (gpuThread > 65536) {\n    gpuThread = 65536\n  }\n  const totalThread = gpuThread + cpuThread\n\n  // 1 cost = 1 Mhash\n  // 1 hash = 0.5 iter\n  const iter = Math.round(cost * 1e6 / 2)\n\n  const {cpuHashPerSec, gpuHashPerSec} = benchmarkInfo!\n  const cpuSpeedRatio = gpuThread\n    ? Math.round(cpuHashPerSec / gpuHashPerSec)\n    : 1\n\n  const sliceNum = gpuThread + cpuThread * cpuSpeedRatio\n  const iterPerSlice = Math.ceil(iter / sliceNum)\n\n  const seedsBuf = new Uint8Array(totalThread * seedLen)\n  fillRandomBytes(seedsBuf)\n\n  const encryptNodes: EncryptNode[] = []\n  const hashesBuf = new Uint8Array(totalThread * SIZE.HASH)\n\n  // `iterRounded` is slightly larger than `iter`\n  const iterRounded = iterPerSlice * sliceNum\n  let iterCompleted = 0\n\n  const onIterAdded = (iterAdded: number) => {\n    iterCompleted += iterAdded\n    onProgress(iterCompleted / iterRounded)\n  }\n\n  const startGpuTask = async () => {\n    if (gpuThread === 0) {\n      return\n    }\n    console.time('gpu encryption')\n\n    const gpuSalt = wasm.getSaltBuf()\n    fillRandomBytes(gpuSalt)\n\n    const INTERVAL = 25\n    const iterPerMs = gpuHashPerSec / 1000 / 2\n    const iterPerDraw = iterPerMs * INTERVAL | 0\n\n    encryptWebGl.setIterPerDraw(iterPerDraw)\n    encryptWebGl.setThread(gpuThread)\n\n    const pbkdf2Ctx = wasm.getCtxBuf(gpuThread)\n    const gpuHashes = wasm.getHashesBuf(gpuThread)\n    const gpuSeeds = seedsBuf.subarray(0, seedLen * gpuThread)\n\n    gpuHashes.set(gpuSeeds)\n    wasm.pbkdf2Pre(gpuThread, seedLen)\n\n    let iterRemain = iterPerSlice\n\n    do {\n      // 1 iter has been performed at pbkdf2Pre\n      const gpuIter = Math.min(iterRemain, NUM.ITER_PER_LOOP) - 1\n      onIterAdded(gpuThread)\n\n      const ctxOut = await encryptWebGl.start(pbkdf2Ctx, gpuIter, onIterAdded)\n      if (!ctxOut) {\n        gpuAvailable = false\n        break\n      }\n      pbkdf2Ctx.set(ctxOut)\n      wasm.pbkdf2Post(gpuThread)\n\n      // next loop\n      wasm.pbkdf2Pre(gpuThread, SIZE.HASH)\n\n      iterRemain -= NUM.ITER_PER_LOOP\n    } while (iterRemain > 0)\n\n    console.timeEnd('gpu encryption')\n\n    if (!gpuAvailable) {\n      if (cpuThread) {\n        encryptCpu.stop()\n      }\n      onProgress(-1)\n      return\n    }\n    encryptNodes[0] = {\n      name: 'GPU (WebGL)',\n      iter: iterPerSlice,\n      seedLen: seedLen,\n      seedNum: gpuThread,\n      seeds: gpuSeeds,\n      salt: cloneBuf(gpuSalt),\n    }\n    hashesBuf.set(gpuHashes)\n  }\n\n  const startCpuTask = async () => {\n    if (cpuThread === 0) {\n      return\n    }\n    console.time('cpu encryption')\n\n    const seedsBegin = seedLen * gpuThread\n    const seedsEnd = seedLen * (gpuThread + cpuThread)\n    const cpuSeeds = seedsBuf.subarray(seedsBegin, seedsEnd)\n\n    const cpuSalt = new Uint8Array(SIZE.SALT)\n    fillRandomBytes(cpuSalt)\n\n    const cpuIter = iterPerSlice * cpuSpeedRatio\n    const cpuHashes = await encryptCpu.start(\n      cpuThread,\n      cpuSeeds,\n      seedLen,\n      cpuSalt,\n      cpuIter,\n      onIterAdded,\n    )\n    console.timeEnd('cpu encryption')\n\n    // aborted\n    if (!cpuHashes) {\n      return\n    }\n    encryptNodes[1] = {\n      name: 'CPU (WebCrypto)',\n      iter: cpuIter,\n      seedNum: cpuThread,\n      seedLen: seedLen,\n      seeds: cpuSeeds,\n      salt: cpuSalt,\n    }\n    hashesBuf.set(cpuHashes, gpuThread * SIZE.HASH)\n  }\n\n  await Promise.all([\n    startGpuTask(),\n    startCpuTask(),\n  ])\n\n  if (!gpuAvailable) {\n    status = Status.READY\n    return\n  }\n\n  // encrypt seeds\n  let key = new Uint8Array(SIZE.HASH)\n\n  for (let i = 0; i < totalThread; i++) {\n    const hash = indexBuf(hashesBuf, SIZE.HASH, i)\n    const seed = indexBuf(seedsBuf, seedLen, i)\n\n    xorBuf(seed, key, seedLen)\n    xorBuf(key, hash, SIZE.HASH)\n  }\n\n  const cipher = await aesEncrypt(plain, key, new Uint8Array(16))\n  const output: DecryptParams = {\n    cost,\n    cipher,\n    nodes: encryptNodes.filter(v => v),\n  }\n  status = Status.READY\n  return output\n}\n","import {\n  SIZE,\n  NUM,\n  DecryptParams,\n  xorBuf,\n  indexBuf,\n  aesDecrypt,\n  isPositiveInt,\n} from './util'\n\nlet isRunning: boolean\nlet isStopping: boolean\nlet pausedSignal: Promise<void> | undefined\nlet resumeCallback: () => void\n\n\nexport async function start(\n  params: DecryptParams,\n  onProgress: (percent: number, hashPerSec: number) => void\n) {\n  if (isRunning) {\n    throw Error('invalid status')\n  }\n  isRunning = true\n  isStopping = false\n\n  let completedIter = 0\n  let totalIter = 0\n\n  for (const item of params.nodes) {\n    const {iter, seedNum, seedLen, seeds} = item\n\n    if (!isPositiveInt(iter)) {\n      throw Error('iter must be a positive integer')\n    }\n    if (!isPositiveInt(seedLen)) {\n      throw Error('seedLen must be a positive integer')\n    }\n    if (!isPositiveInt(seedNum)) {\n      throw Error('thread must be a positive integer')\n    }\n    if (seeds.length !== seedLen * seedNum) {\n      throw Error('seeds.length != seedLen * thread')\n    }\n    totalIter += iter * seedNum\n  }\n\n  const pbkdfOpt: Pbkdf2Params = {\n    name: 'PBKDF2',\n    hash: 'SHA-256',\n    salt: undefined!,\n    iterations: 0,\n  }\n\n  const slowHash = async (seed: Uint8Array, iter: number) => {\n    const loop = Math.ceil(iter / NUM.ITER_PER_LOOP)\n\n    let hash = seed\n    let iterRemain = iter\n\n    for (let i = 0; i < loop; i++) {\n      pbkdfOpt.iterations = Math.min(iterRemain, NUM.ITER_PER_LOOP)\n      iterRemain -= NUM.ITER_PER_LOOP\n\n      const k = await crypto.subtle.importKey(\n        'raw', hash, 'PBKDF2', false, ['deriveBits']\n      )\n      const startTime = performance.now()\n      const buf = await crypto.subtle.deriveBits(pbkdfOpt, k, SIZE.HASH * 8)\n      const endTime = performance.now()\n\n      const time = endTime - startTime\n      const iterPerMs = pbkdfOpt.iterations / time\n      const hashPerSec = iterPerMs * 1000 * 2\n\n      hash = new Uint8Array(buf)\n\n      if (pausedSignal) {\n        await pausedSignal\n      }\n      if (isStopping) {\n        break\n      }\n      completedIter += pbkdfOpt.iterations\n      onProgress(completedIter / totalIter, hashPerSec)\n    }\n    return hash\n  }\n\n  // XOR'd with zero will be itself\n  const key = new Uint8Array(SIZE.HASH)\n\n  for (const item of params.nodes) {\n    const {iter, seedNum, seedLen, seeds, salt} = item\n\n    const saltIdBuf = new Uint8Array(salt.length + 4)\n    const saltIdView = new DataView(saltIdBuf.buffer)\n\n    saltIdBuf.set(salt)\n    pbkdfOpt.salt = saltIdBuf\n\n    for (let p = 0; p < seedNum; p++) {\n      saltIdView.setUint32(salt.length, p)\n\n      const seed = indexBuf(seeds, seedLen, p)\n      xorBuf(seed, key, seedLen)\n\n      const hash = await slowHash(seed, iter)\n      xorBuf(key, hash, SIZE.HASH)\n\n      if (isStopping) {\n        isRunning = false\n        return\n      }\n    }\n  }\n\n  try {\n    return await aesDecrypt(params.cipher, key, new Uint8Array(16))\n  } catch {\n  } finally {\n    isRunning = false\n  }\n}\n\nexport function pause() {\n  pausedSignal = new Promise(resolve => {\n    resumeCallback = resolve\n  })\n}\n\nexport function resume() {\n  pausedSignal = undefined\n  resumeCallback()\n}\n\nexport function stop() {\n  isStopping = true\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","fillRandomBytes","buf","i","length","slice","subarray","crypto","getRandomValues","xorBuf","dst","src","len","indexBuf","sliceLen","index","offset","cloneBuf","isUint","Math","floor","isPositiveInt","workerEnv","sendMsgToPage","postMessage","pausedSignal","resumeCallback","isStopping","self","onmessage","e","msg","data","type","async","params","seed","salt","iter","loop","ceil","pbkdfOpt","name","hash","iterations","iterRemain","min","k","subtle","importKey","deriveBits","Uint8Array","iterAdded","start","Promise","resolve","undefined","pwd","opt","startTime","performance","now","endTime","benchmark","MyWorker","Worker","threadId","constructor","url","super","sendMsg","workerPool","workerUrl","completedHashes","completedNum","threadNum","benchmarkInfo","benchmarkCallback","encryptOnComplete","encryptOnProgress","allocWorker","id","blob","Blob","URL","createObjectURL","worker","onWorkerMsg","sendMsgToWorkers","this","bufs","ret","pos","v","set","concatBuf","push","startTimeMin","map","endTimeMax","max","benchmarkThread","thread","p","stop","texW","gl","iterHandle","iterPerDraw","sleep","ms","fn","setTimeout","createShader","code","shader","Error","shaderSource","compileShader","getShaderParameter","getShaderInfoLog","setIterPerDraw","uniform1ui","setThread","viewport","outTex","createTexture","bindTexture","texImage2D","framebufferTexture2D","drawBuffers","inTex","texParameteri","write","texH","read","ptr","readBuffer","readPixels","draw","drawArrays","dstX","dstY","copyTexSubImage2D","errMsg","canvas","OffscreenCanvas","ctx","getContext","failIfMajorPerformanceCaveat","powerPreference","oncontextlost","console","warn","oncontextrestored","vertexData","Float32Array","bindBuffer","createBuffer","bufferData","program","createProgram","vertexShader","fragShader","replace","attachShader","linkProgram","useProgram","vertexAttribPointer","enableVertexAttribArray","getUniformLocation","frameBuffer","createFramebuffer","bindFramebuffer","initWebGl","err","message","init","ctxBuf","drawCount","backup","isContextLost","Uint32Array","timeMin","time","initCallback","benchmarkThreadCallback","completeCallback","progressCallback","sendMsgToWorker","onProgress","wasmObj","pbkdf2Pre","gpuThread","elemLen","pbkdf2_pre","pbkdf2Post","pbkdf2_post","BENCHMARK_FILE","isRunning","gpuAvailable","res","fetch","instance","WebAssembly","instantiateStreaming","cache","caches","open","match","readCache","info","json","cpuThread","cpuHashPerSec","gpuHashPerSec","readInfo","isGpuAvailable","PROBE_ITER","log","iterPerSec","singleThreadTime","iterPerMs","window","navigator","hardwareConcurrency","tryThread","ratio","multiThreadTime","JSON","stringify","Response","put","writeCache","saveInfo","getBenchmarkInfo","plain","cost","seedLen","log2","totalThread","round","cpuSpeedRatio","sliceNum","iterPerSlice","seedsBuf","encryptNodes","hashesBuf","iterRounded","iterCompleted","onIterAdded","all","gpuSalt","get_salt_buf","memory","buffer","pbkdf2Ctx","get_ctx_buf","gpuHashes","get_hashes_buf","gpuSeeds","gpuIter","ctxOut","timeEnd","seedNum","seeds","startGpuTask","seedsBegin","seedsEnd","cpuSeeds","cpuSalt","cpuIter","cpuHashes","saltBuf","saltIdBuf","saltIdView","DataView","setUint32","startCpuTask","cipher","iv","encrypt","aesEncrypt","output","nodes","filter","completedIter","totalIter","item","slowHash","hashPerSec","decrypt","aesDecrypt"],"sourceRoot":""}